import{S as e,i as a,s as o,e as n,t as r,k as t,c as s,a as i,g as l,d as c,n as d,b as h,f,F as u,G as g}from"../../chunks/vendor-07557843.js";function m(e){let a,o,m,p,E,v,w,J,D,C,O,b,y,T,S,P,x,N,I,k,H,R,M,j,q,L,_,z,A,B,F,G,K,U,V,W,Z,Q,X,Y,$,ee,ae,oe,ne,re,te,se,ie,le,ce,de,he,fe,ue,ge,me,pe,Ee,ve,we,Je,De,Ce,Oe,be,ye,Te,Se,Pe,xe,Ne,Ie,ke,He,Re,Me,je,qe,Le,_e,ze,Ae,Be,Fe,Ge,Ke,Ue,Ve,We;return{c(){a=n("p"),o=r("The nullish coalescing operator "),m=n("code"),p=r("??"),E=r(" is an ES2020 feature that brings a new logical operator to JavaScript, and it works differently from its counterparts."),v=t(),w=n("p"),J=r("In JavaScript, operators are evaluated from left to right and contain two arguments. If the first argument is sufficient to determine the outcome the second one is skipped. This is called short-circuit evaluation and the nullish coalescing "),D=n("code"),C=r("??"),O=r(" adds a third to a list of existing operators that have this feature: "),b=n("code"),y=r("&&"),T=r(" and "),S=n("code"),P=r("||"),x=r("."),N=t(),I=n("h2"),k=r("Definition"),H=t(),R=n("p"),M=n("a"),j=r("The nullish coalescing operator ("),q=n("code"),L=r("??"),_=r(")"),z=r(" is a logical operator that returns it’s right-hand side operand when its left-hand side operand is "),A=n("code"),B=r("null"),F=r(" or "),G=n("code"),K=r("undefined"),U=r(", and otherwise returns its left-hand side operand."),V=t(),W=n("p"),Z=r("This operator is especially useful when we want  "),Q=n("em"),X=r("falsy"),Y=r(" values like "),$=n("code"),ee=r("0"),ae=r(" or "),oe=n("code"),ne=r("false"),re=r(" to be considered a valid value."),te=t(),se=n("h2"),ie=r("Syntax"),le=t(),ce=n("pre"),de=t(),he=n("pre"),fe=t(),ue=n("p"),ge=r("This is different from the logical OR ("),me=n("code"),pe=r("||"),Ee=r(") operator, where any "),ve=n("em"),we=r("falsy"),Je=r(" value is not considered valid: "),De=n("code"),Ce=r("undefined"),Oe=r(", "),be=n("code"),ye=r("null"),Te=r(", "),Se=n("code"),Pe=r("””"),xe=r(", "),Ne=n("code"),Ie=r("0"),ke=r(", "),He=n("code"),Re=r("false"),Me=r(", or "),je=n("code"),qe=r("NaN"),Le=r(". Below is a comparison of both:"),_e=t(),ze=n("pre"),Ae=t(),Be=n("h2"),Fe=r("Chaining"),Ge=t(),Ke=n("p"),Ue=r("Chaining is possible, but with this new operator it will require us to explicitly denote the order of evaluations; otherwise, we’ll get an error."),Ve=t(),We=n("pre"),this.h()},l(e){a=s(e,"P",{});var n=i(a);o=l(n,"The nullish coalescing operator "),m=s(n,"CODE",{});var r=i(m);p=l(r,"??"),r.forEach(c),E=l(n," is an ES2020 feature that brings a new logical operator to JavaScript, and it works differently from its counterparts."),n.forEach(c),v=d(e),w=s(e,"P",{});var t=i(w);J=l(t,"In JavaScript, operators are evaluated from left to right and contain two arguments. If the first argument is sufficient to determine the outcome the second one is skipped. This is called short-circuit evaluation and the nullish coalescing "),D=s(t,"CODE",{});var h=i(D);C=l(h,"??"),h.forEach(c),O=l(t," adds a third to a list of existing operators that have this feature: "),b=s(t,"CODE",{});var f=i(b);y=l(f,"&&"),f.forEach(c),T=l(t," and "),S=s(t,"CODE",{});var u=i(S);P=l(u,"||"),u.forEach(c),x=l(t,"."),t.forEach(c),N=d(e),I=s(e,"H2",{});var g=i(I);k=l(g,"Definition"),g.forEach(c),H=d(e),R=s(e,"P",{});var Ze=i(R);M=s(Ze,"A",{href:!0,rel:!0});var Qe=i(M);j=l(Qe,"The nullish coalescing operator ("),q=s(Qe,"CODE",{});var Xe=i(q);L=l(Xe,"??"),Xe.forEach(c),_=l(Qe,")"),Qe.forEach(c),z=l(Ze," is a logical operator that returns it’s right-hand side operand when its left-hand side operand is "),A=s(Ze,"CODE",{});var Ye=i(A);B=l(Ye,"null"),Ye.forEach(c),F=l(Ze," or "),G=s(Ze,"CODE",{});var $e=i(G);K=l($e,"undefined"),$e.forEach(c),U=l(Ze,", and otherwise returns its left-hand side operand."),Ze.forEach(c),V=d(e),W=s(e,"P",{});var ea=i(W);Z=l(ea,"This operator is especially useful when we want  "),Q=s(ea,"EM",{});var aa=i(Q);X=l(aa,"falsy"),aa.forEach(c),Y=l(ea," values like "),$=s(ea,"CODE",{});var oa=i($);ee=l(oa,"0"),oa.forEach(c),ae=l(ea," or "),oe=s(ea,"CODE",{});var na=i(oe);ne=l(na,"false"),na.forEach(c),re=l(ea," to be considered a valid value."),ea.forEach(c),te=d(e),se=s(e,"H2",{});var ra=i(se);ie=l(ra,"Syntax"),ra.forEach(c),le=d(e),ce=s(e,"PRE",{class:!0}),i(ce).forEach(c),de=d(e),he=s(e,"PRE",{class:!0}),i(he).forEach(c),fe=d(e),ue=s(e,"P",{});var ta=i(ue);ge=l(ta,"This is different from the logical OR ("),me=s(ta,"CODE",{});var sa=i(me);pe=l(sa,"||"),sa.forEach(c),Ee=l(ta,") operator, where any "),ve=s(ta,"EM",{});var ia=i(ve);we=l(ia,"falsy"),ia.forEach(c),Je=l(ta," value is not considered valid: "),De=s(ta,"CODE",{});var la=i(De);Ce=l(la,"undefined"),la.forEach(c),Oe=l(ta,", "),be=s(ta,"CODE",{});var ca=i(be);ye=l(ca,"null"),ca.forEach(c),Te=l(ta,", "),Se=s(ta,"CODE",{});var da=i(Se);Pe=l(da,"””"),da.forEach(c),xe=l(ta,", "),Ne=s(ta,"CODE",{});var ha=i(Ne);Ie=l(ha,"0"),ha.forEach(c),ke=l(ta,", "),He=s(ta,"CODE",{});var fa=i(He);Re=l(fa,"false"),fa.forEach(c),Me=l(ta,", or "),je=s(ta,"CODE",{});var ua=i(je);qe=l(ua,"NaN"),ua.forEach(c),Le=l(ta,". Below is a comparison of both:"),ta.forEach(c),_e=d(e),ze=s(e,"PRE",{class:!0}),i(ze).forEach(c),Ae=d(e),Be=s(e,"H2",{});var ga=i(Be);Fe=l(ga,"Chaining"),ga.forEach(c),Ge=d(e),Ke=s(e,"P",{});var ma=i(Ke);Ue=l(ma,"Chaining is possible, but with this new operator it will require us to explicitly denote the order of evaluations; otherwise, we’ll get an error."),ma.forEach(c),Ve=d(e),We=s(e,"PRE",{class:!0}),i(We).forEach(c),this.h()},h(){h(M,"href","https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator"),h(M,"rel","nofollow"),h(ce,"class","language-undefined"),h(he,"class","language-undefined"),h(ze,"class","language-undefined"),h(We,"class","language-undefined")},m(e,n){f(e,a,n),u(a,o),u(a,m),u(m,p),u(a,E),f(e,v,n),f(e,w,n),u(w,J),u(w,D),u(D,C),u(w,O),u(w,b),u(b,y),u(w,T),u(w,S),u(S,P),u(w,x),f(e,N,n),f(e,I,n),u(I,k),f(e,H,n),f(e,R,n),u(R,M),u(M,j),u(M,q),u(q,L),u(M,_),u(R,z),u(R,A),u(A,B),u(R,F),u(R,G),u(G,K),u(R,U),f(e,V,n),f(e,W,n),u(W,Z),u(W,Q),u(Q,X),u(W,Y),u(W,$),u($,ee),u(W,ae),u(W,oe),u(oe,ne),u(W,re),f(e,te,n),f(e,se,n),u(se,ie),f(e,le,n),f(e,ce,n),ce.innerHTML='<code class="language-undefined">value ?? defaultValue</code>',f(e,de,n),f(e,he,n),he.innerHTML='<code class="language-undefined">const name == null ?? &#39;Jane Doe&#39;\nconsole.log(name); // =&gt; Jane Doe</code>',f(e,fe,n),f(e,ue,n),u(ue,ge),u(ue,me),u(me,pe),u(ue,Ee),u(ue,ve),u(ve,we),u(ue,Je),u(ue,De),u(De,Ce),u(ue,Oe),u(ue,be),u(be,ye),u(ue,Te),u(ue,Se),u(Se,Pe),u(ue,xe),u(ue,Ne),u(Ne,Ie),u(ue,ke),u(ue,He),u(He,Re),u(ue,Me),u(ue,je),u(je,qe),u(ue,Le),f(e,_e,n),f(e,ze,n),ze.innerHTML='<code class="language-undefined">let name\nconsole.log(name ?? &#39;Jane&#39;) // =&gt; Jane\nconsole.log(name || &#39;Jane&#39;) // =&gt; Jane\n\nlet name = null\nconsole.log(name ?? &#39;Jane&#39;) // =&gt; Jane\nconsole.log(name || &#39;Jane&#39;) // =&gt; Jane\n\nlet name = NaN\nconsole.log(name ?? &#39;Jane&#39;) // =&gt; NaN\nconsole.log(name || &#39;Jane&#39;) // =&gt; Jane\n\nlet name = 0\nconsole.log(name ?? &#39;Jane&#39;) // =&gt; 0\nconsole.log(name || &#39;Jane&#39;) // =&gt; Jane\n\nlet name = false\nconsole.log(name ?? &#39;Jane&#39;) // =&gt; false\nconsole.log(name || &#39;Jane&#39;) // =&gt; Jane\n\nlet name = &#39;&#39;\nconsole.log(name ?? &#39;Jane&#39;) // =&gt; &#39;&#39;\nconsole.log(name || &#39;Jane&#39;) // =&gt; Jane</code>',f(e,Ae,n),f(e,Be,n),u(Be,Fe),f(e,Ge,n),f(e,Ke,n),u(Ke,Ue),f(e,Ve,n),f(e,We,n),We.innerHTML='<code class="language-undefined">const name = user.full_name || user.username ?? &#39;Jane Doe&#39; \n// =&gt; SyntaxError\nconst name = (user.full_name || user.username) ?? &#39;Jane Doe&#39; \n// =&gt; Jane Doe</code>'},p:g,i:g,o:g,d(e){e&&c(a),e&&c(v),e&&c(w),e&&c(N),e&&c(I),e&&c(H),e&&c(R),e&&c(V),e&&c(W),e&&c(te),e&&c(se),e&&c(le),e&&c(ce),e&&c(de),e&&c(he),e&&c(fe),e&&c(ue),e&&c(_e),e&&c(ze),e&&c(Ae),e&&c(Be),e&&c(Ge),e&&c(Ke),e&&c(Ve),e&&c(We)}}}const p={title:"Nullish Coalescing Operator",published:"2020-11-07T00:00:00.000Z",description:"Familiarize yourself with the nullish coalescing operator",focusKeyphrase:"best medium format camera",featuredImage:"best-medium-format-camera-for-starting-out.jpg",featuredImageAlt:"Photograph of a Hasselblad medium format camera with the focusing screen exposed",ogImage:"best-medium-format-camera-for-starting-out-open-graph.jpg",ogSquareImage:"best-medium-format-camera-for-starting-out-open-graph-square.jpg",twitterImage:"best-medium-format-camera-for-starting-out-twitter.jpg",categories:"",tags:""};class E extends e{constructor(e){super(),a(this,e,null,m,o,{})}}export{E as default,p as metadata};
